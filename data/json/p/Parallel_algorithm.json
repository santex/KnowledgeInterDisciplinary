{"cursor":"4074","size":15,"audio":[],"currentlang":"en","article":"\nIn computer science, a 'parallel algorithm' or 'concurrent algorithm', as\nopposed to a traditional sequential (or serial) algorithm, is an algorithm which\ncan be executed a piece at a time on many different processing devices, and then\ncombined together again at the end to get the correct result.\n\nSome algorithms are easy to divide up into pieces in this way. For example,\nsplitting up the job of checking all of the numbers from one to a hundred\nthousand to see which are primes could be done by assigning a subset of the\nnumbers to each available processor, and then putting the list of positive\nresults back together. Algorithms are also used for things such as rubik's\ncubing and for hash decryption.\n\nMost of the available algorithms to compute pi (Ï), on the other hand, cannot be\neasily split up into parallel portions. They require the results from a\npreceding step to effectively carry on with the next step. Such problems are\ncalled inherently serial problems. Iterative numerical methods, such as Newton's\nmethod or the three-body problem, are also algorithms which are inherently\nserial. Some problems are very difficult to parallelize, although they are\nrecursive. One such example is the depth-first search of graphs.\n\nParallel algorithms are valuable because of substantial improvements in\nmultiprocessing systems and the rise of multi-core processors. In general, it is\neasier to construct a computer with a single fast processor than one with many\nslow processors with the same throughput. But processor speed is increased\nprimarily by shrinking the circuitry, and modern processors are pushing physical\nsize and heat limits. These twin barriers have flipped the equation, making\nmultiprocessing practical even for small systems.\n\nThe cost or complexity of serial algorithms is estimated in terms of the\nspace (memory) and time (processor cycles) that they take. Parallel\nalgorithms need to optimize one more resource, the communication between\ndifferent processors. There are two ways parallel processors communicate,\nshared memory or message passing.\n\nShared memory processing needs additional locking for the data, imposes the\noverhead of additional processor and bus cycles, and also serializes some\nportion of the algorithm.\n\nMessage passing processing uses channels and message boxes but this\ncommunication adds transfer overhead on the bus, additional memory need for\nqueues and message boxes and latency in the messages. Designs of parallel\nprocessors use special buses like crossbar so that the communication\noverhead will be small but it is the parallel algorithm that decides the\nvolume of the traffic.\n\nAnother problem with parallel algorithms is ensuring that they are suitably\nload balanced. For example, checking all numbers from one to a hundred thousand\nfor primality is easy to split amongst processors; however, some processors\nwill get more work to do than the others, which will sit idle until the loaded\nprocessors complete.\n\nA subtype of parallel algorithms, [[distributed algorithms]] are algorithms\ndesigned to work in cluster computing and distributed computing environments,\nwhere additional concerns beyond the scope of \"classical\" parallel algorithms\nneed to be addressed.\n","linknr":116,"url":"Parallel_algorithm","recorded":1362545476,"links":22,"instances":["computer_science","computing","data_structure"],"pdf":[],"categories":["Parallel computing","Concurrent algorithms","Distributed algorithms"],"headings":["See also","References","External links"],"image":["//upload.wikimedia.org/wikipedia/en/thumb/9/99/Question_book-new.svg/50px-Question_book-new.svg.png","//bits.wikimedia.org/static-1.21wmf10/skins/vector/images/search-ltr.png?303-4","//bits.wikimedia.org/images/wikimedia-button.png","//bits.wikimedia.org/static-1.21wmf10/skins/common/images/poweredby_mediawiki_88x31.png"],"tags":[["graph","data_structure"],["lock","computer_science"],["load_balancing","computing"]],"members":["lock","load_balancing","graph"],"related":["Computer_science","Sequential_algorithm","Algorithm","Prime_number","Pi","Numerical_analysis","Newton's_method","Three-body_problem","Depth-first_search","Graph_(data_structure)","Multiprocessing","Multi-core","Throughput","Shared_memory","Lock_(computer_science)","Message_passing","Load_balancing_(computing)","Cluster_computing","Distributed_computing","Multiple-agent_system","Neural_network","Parallel_computing"]}
{"cursor":"4871","size":15,"audio":[],"currentlang":"en","article":"'Saturation arithmetic' is a version of arithmetic in which all operations such\nas addition and multiplication are limited to a fixed range between a minimum\nand maximum value. If the result of an operation is greater than the maximum, it\nis set (\"clamped\") to the maximum; if it is below the minimum, it is clamped to\nthe minimum. The name comes from how the value becomes \"saturated\" once it\nreaches the extreme values; further additions to a maximum or subtractions from\na minimum will not change the result.\n\nFor example, if the valid range of values is from -100 to 100, the following\noperations produce the following values:\n* 60 + 43 = 100\n* (60 + 43) â 150 = â50\n* 43 â 150 = â100\n* 60 + (43 â 150) = â40\n* 10 Ã 11 = 100\n* 99 Ã 99 = 100\n* 30 Ã (5 â 1) = 100\n* 30 Ã 5 â 30 Ã 1 = 70 As can be seen from these examples, familiar properties\n  like associativity and distributivity fail in saturation arithmetic. This\n  makes it unpleasant to deal with in abstract mathematics, but it has an\n  important role to play in digital hardware and algorithms.\n\nTypically, early computer microprocessors did not implement integer arithmetic\noperations using saturation arithmetic; instead, they used the easier-to-\nimplement modular arithmetic, in which values exceeding the maximum value \"wrap\naround\" to the minimum value, like the hours on a clock passing from 12 to 1. In\nhardware, modular arithmetic with a minimum of zero and a maximum of 2 n-\n1 can be implemented by simply discarding all but the lowest n bits.\n\nHowever, although more difficult to implement, saturation arithmetic has\nnumerous practical advantages. The result is as numerically close to the true\nanswer as possible; it's considerably less surprising to get an answer of 127\ninstead of 130 than to get an answer of â126 instead of 130. It also enables\noverflow of additions and multiplications to be detected consistently without an\noverflow bit or excessive computation by simple comparison with the maximum or\nminimum value (provided the datum is not permitted to take on these values).\n\nAdditionally, saturation arithmetic enables efficient algorithms for many\nproblems, particularly in digital signal processing. For example, adjusting the\nvolume level of a sound signal can result in overflow, and saturation causes\nsignificantly less distortion to the sound than wrap-around. In the words of\nresearchers G. A. Constantinides et al.:\n\n\n\nSaturation arithmetic operations are available on many modern platforms, and in\nparticular was one of the extensions made by the Intel MMX platform,\nspecifically for such signal processing applications.\n\nSaturation arithmetic for integers has also been implemented in software for a\nnumber of programming languages including C, C++, Eiffel. This helps programmers\nanticipate and understand the effects of overflow better. On the other hand,\nsaturation is challenging to implement efficiently in software on a machine with\nonly modular arithmetic operations, since simple implementations require\nbranches that create huge pipeline delays.\n\nAlthough saturation arithmetic is less popular for integer arithmetic in\nhardware, the IEEE floating-point standard, the most popular abstraction for\ndealing with approximate real numbers, uses a form of saturation in which\noverflow is converted into \"infinity\" or \"negative infinity\", and any other\noperation on this result continues to produce the same value. This has the\nadvantage over simple saturation that later operations which decrease the value\nwill not end up producing a \"reasonable\" result, such as in the computation \\sqrt{x^2-\ny^2} .\n","linknr":91,"url":"Saturation_arithmetic","recorded":1362480464,"links":13,"instances":["programming_language","programming_language","instruction_set"],"pdf":[],"categories":["Computer arithmetic"],"headings":["Notes","External links"],"image":["//upload.wikimedia.org/math/f/0/f/f0f90d1d4d0e386d9a3ce44e3feb2bd0.png","//bits.wikimedia.org/static-1.21wmf9/skins/vector/images/search-ltr.png?303-4","//bits.wikimedia.org/images/wikimedia-button.png","//bits.wikimedia.org/static-1.21wmf9/skins/common/images/poweredby_mediawiki_88x31.png"],"tags":[["mmx","instruction_set"],["c","programming_language"],["eiffel","programming_language"],["eiffel","programming_language"]],"members":["c","eiffel","mmx"],"related":["Arithmetic","Associativity","Distributivity","Digital_hardware","Microprocessor","Modular_arithmetic","Integer_overflow","Digital_signal_processing","MMX_(instruction_set)","C_(programming_language)","C++","Eiffel_(programming_language)","IEEE_floating-point_standard","Eiffel_(programming_language)"]}
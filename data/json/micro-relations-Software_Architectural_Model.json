{"cursor":"5256","size":15,"audio":[],"currentlang":"en","article":"\n\nAn 'architectural model' (in software) is a rich and rigorous diagram, created\nusing available standards, in which the primary concern is to illustrate a\nspecific set of tradeoffs inherent in the structure and design of a system or\necosystem. Software architects use architectural models to communicate with\nothers and seek peer feedback.\n\nAn architectural model is an expression of a viewpoint in software architecture.\nThere are many definitions of software architecture (see external links).\n\nKey elements of the definition of a software architectural model:\n\n*'rich': for the viewpoint in question, there should be sufficient information\nto describe the area in detail. The information should not be lacking or vague.\nThe goal is to minimize misunderstandings, not perpetuate them. See notes below\non 'primary concern.'\n* 'rigorous': the architect has applied a specific methodology to create this\n  particular model, and the resulting model 'looks' a particular way. Here's the\n  test of rigorousness: If two architects, in different cities, were describing\n  the same thing, the resulting diagrams would be nearly identical (with the\n  possible exception of visual layout, to a point).\n* 'diagram': in general, a model may refer to any abstraction that simplifies\n  something for the sake of addressing a particular viewpoint. This definition\n  specifically subclasses 'architectural models' to the subset of model\n  descriptions that are represented as diagrams. *'standards': standards work\n  when everyone knows them and everyone uses them. This allows a level of\n  communication that cannot be achieved when each diagram is substantially\n  different from another. UML is the most often quoted standard.\n* 'primary concern': it is easy to be too detailed by including many different\n  needs in a single diagram. This should be avoided. It is better to draw\n  multiple diagrams, one for each viewpoint, than to draw a 'mega diagram' that\n  is so rich in content that it requires a two-year course of study to\n  understand it. Remember this: when building houses, the architect delivers\n  many different diagrams. Each is used differently. Frequently the final\n  package of plans will include diagrams with the floor plan many times: framing\n  plan, electrical plan, heating plan, plumbing, etc. They don't just say: it's\n  a floor plan so 100% of the information that CAN go on a floor plan should be\n  put there. The plumbing subcontractor doesn't need the details that the\n  electrician cares about.\n* 'illustrate': the idea behind creating a model is to communicate and seek\n  valuable feedback. The goal of the diagram should be to answer a specific\n  question and to share that answer with others to (a) see if they agree, and\n  (b) guide their work. Rule of thumb: know what it is you want to say, and\n  whose work you intend to influence with it.\n* 'specific set of tradeoffs': the architecture tradeoff analysis method (ATAM)\n  methodology describes a process whereby software architecture can be peer-\n  reviewed for appropriateness. ATAM does this by starting with a basic notion:\n  there is no such thing as a 'one-size-fits-all' design. We can create a\n  generic design, but then we need to alter it to specific situations based on\n  the business requirements. In effect, we make tradeoffs. The diagram should\n  make those specific tradeoffs visible. Therefore, before an architect creates\n  a diagram, he or she should be prepared to describe, in words, which tradeoffs\n  they are attempting to illustrate in this model.\n* 'tradeoffs inherent in the structure and design': a component is not a\n  tradeoff. Tradoffs rarely translate into an image on the diagram. Tradeoffs\n  are the first principles that produced the design models. When an architect\n  wishes to describe or defend a particular tradeoff, the diagram can be used to\n  defend the position.\n* 'system or ecosystem': modeling in general can be done at different levels of\n  abstraction. It is useful to model the architecture of a specific application,\n  complete with components and interactions. It is also reasonable to model the\n  systems of applications needed to deliver a complete business process (like\n  order-to-cash). It is not commonly useful, however, to view the model of a\n  single component and its classes as software architecture. At that level, the\n  model, while valuable in its own right, illustrates design much more so than\n  architecture.\n","linknr":93,"url":"Software_Architectural_Model","recorded":1362374842,"links":14,"instances":[],"pdf":[],"categories":["Software architecture"],"headings":["References","External links","See also"],"image":["//upload.wikimedia.org/wikipedia/en/f/f4/Ambox_content.png","//upload.wikimedia.org/wikipedia/commons/thumb/a/a4/Text_document_with_red_question_mark.svg/40px-Text_document_with_red_question_mark.svg.png","//upload.wikimedia.org/wikipedia/en/thumb/f/f2/Edit-clear.svg/40px-Edit-clear.svg.png","//bits.wikimedia.org/static-1.21wmf10/skins/vector/images/search-ltr.png?303-4","//bits.wikimedia.org/images/wikimedia-button.png","//bits.wikimedia.org/static-1.21wmf10/skins/common/images/poweredby_mediawiki_88x31.png"],"tags":[],"members":[],"related":["Software","Software_architect","Architecture_tradeoff_analysis_method","Service-oriented_modeling"]}
{"cursor":"5751","size":15,"audio":[],"currentlang":"en","article":"In computer chess and other computer games, 'transposition tables' are used to\nspeed up the search of the game tree. Transposition tables are primarily useful\nin perfect information games, meaning the entire state of the game is known to\nall players at all times.\n\nGame playing programs work by analyzing millions of positions that could arise\nin the next few moves of the game. Typically, these programs employ strategies\nresembling depth-first search, which means that they do not keep track of all\nthe positions analyzed so far. In many games, it is possible to reach a given\nposition in more than one way. These are called transpositions. [http://www-\n.gamedev.net/page/resources/_/technical/artificial-intelligence/chess-\nprogramming-part-ii-data-structures-r1046 Transposition Tables] Gamedev.net, Francois-\nDominic Laramee In chess, for example, the sequence of moves '1.' d4\nNf6'2.' c4 g6 (see algebraic chess notation) has 4 possible transpositions,\nsince either player may swap their move order. In general, after n moves, an\nupper limit on the possible transpositions is (n!)Â². Although many of these are\nillegal move sequences, it is still likely that the program will end up\nanalyzing the same position several times.\n\nTo avoid this problem, transposition tables are used. Such a table is a hash\ntable of each of the positions analyzed so far up to a certain depth. On\nencountering a new position, the program checks the table to see if the position\nhas already been analyzed; this can be done quickly, in expected constant time.\nIf so, the table contains the value that was previously assigned to this\nposition; this value is used directly. If not, the value is computed and the new\nposition is entered into the hash table. This is essentially memoization applied\nto the search function.\n\nThe number of positions searched by a computer often greatly exceeds the memory\nconstraints of the system it runs on; thus not all positions can be stored. When\nthe table fills up, less-used positions are removed to make room for new ones;\nthis makes the transposition table a kind of cache.\n\nThe computation saved by a transposition table lookup is not just the evaluation\nof a single position - if that were the case, it would hardly be worth the\neffort, since evaluation functions are designed to be very fast anyway. Instead,\nthe evaluation of an entire subtree is avoided. Thus, transposition table\nentries for nodes at a shallower depth in the game tree are more valuable (since\nthe size of the subtree rooted at such a node is larger) and are therefore given\nmore importance when the table fills up and some entries must be discarded.\n\nThe hash table implementing the transposition table can have other uses than\nfinding transpositions. In alpha-beta pruning, the search is fastest (in fact,\noptimal) when the child of a node corresponding to the best move is always\nconsidered first. Of course there is no way of knowing the best move, but when\niterative deepening is used, the move which was found to be the best in a\nshallower search is a good approximation. Therefore this move is tried first.\nFor storing the best child of a node, the entry corresponding to that node in\nthe transposition table is used.\n\nUse of a transposition table can lead to incorrect results if the Graph History\nInteraction problem is not studiously avoided. This problem arises in certain\ngames because the history of a position may be important. For example, in chess\na player may not castle if the king or the rook to be castled with has moved\nduring the course of the game. A common solution to this problem is to add the\ncastling rights as part of the Zobrist hashing key. Another example is draw by\nrepetition: given a position, it may not be possible to determine if it has\nalready occurred. A solution to the general problem is to store history\ninformation in each node of the transposition table, but this is inefficient and\nrarely done in practice.\n","linknr":103,"url":"Transposition_table","recorded":1362903497,"links":10,"instances":["chess","chess"],"pdf":[],"categories":["Game artificial intelligence","Computer chess"],"headings":["Related techniques","See also","Notes and references","External links"],"image":["//bits.wikimedia.org/static-1.21wmf9/skins/vector/images/search-ltr.png?303-4","//bits.wikimedia.org/images/wikimedia-button.png","//bits.wikimedia.org/static-1.21wmf9/skins/common/images/poweredby_mediawiki_88x31.png"],"tags":[["transposition","chess"],["cache","computing"],["pawn","chess"],["cache","computing#operation"]],"members":["pawn","transposition","cache"],"related":["Computer_chess","Game_tree","Perfect_information","Depth-first_search","Transposition_(chess)","Chess","Algebraic_chess_notation","Hash_table","Memoization","Cache_(computing)","Evaluation_function","Alpha-beta_pruning","Iterative_deepening_depth-first_search","Chess","Zobrist_hashing","Threefold_repetition","Pawn_(chess)","Principal_variation","Minimax_algorithm","Alpha-beta_pruning","Zobrist_hashing"]}
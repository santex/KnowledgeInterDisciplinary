{"cursor":"12509","size":15,"audio":[],"currentlang":"en","article":"\n\nIn computing, 'reactive programming' is a programming paradigm oriented around\ndata flows and the propagation of change. This means that it should be possible\nto express static or dynamic data flows with ease in the programming languages\nused, and that the underlying execution model will automatically propagate\nchanges through the data flow.\n\nFor example, in an imperative programming setting, a := b + c would\nmean that a is being assigned the result of b + c in\nthe instant the expression is evaluated. Later, the values of b and\nc can be changed with no effect on the value of a .\n\nIn reactive programming, the value of a would be automatically\nupdated based on the new values.\n\nA modern spreadsheet program is an example of reactive programming. Spreadsheet\ncells can contain literal values, or formulas such as \"=B1+C1\" that are\nevaluated based on other cells. Whenever the value of the other cells change,\nthe value of the formula is automatically updated.\n\nAnother example is a hardware description language such as Verilog. In this\ncase reactive programming allows us to model changes as they propagate through\na circuit.\n\nReactive programming has foremost been proposed as a way to simplify the\ncreation of interactive user interfaces, animations in real time systems, but is\nessentially a general programming paradigm.\n\nFor example, in a Model-view-controller architecture, reactive programming can\nallow changes in the underlying model to automatically be reflected in the view,\nand vice versa. [http://peak.telecommunity.com/DevCenter/Trellis#model-view-\ncontroller-and-the-observer-pattern Model-view-controller and the observer\npattern]\n","linknr":281,"url":"Reactive_programming","recorded":1362572851,"links":18,"instances":["programming_language"],"pdf":["http://www.cs.nott.ac.uk/~nhn/FoPAD2007/Talks/nhn-FoPAD2007.pdf","http://lamp.epfl.ch/~imaier/pub/DeprecatingObserversTR2010.pdf"],"categories":["Programming paradigms","Evaluation strategy"],"headings":["Concepts","Approaches","See also","References","External links"],"image":["//upload.wikimedia.org/math/4/1/1/4119896868de71d3dec7aa397c766137.png","//upload.wikimedia.org/math/0/c/c/0cc175b9c0f1b6a831c399e269772661.png","//upload.wikimedia.org/math/a/3/9/a39f24a429c5d7327a4a07a68c1c51ad.png","//upload.wikimedia.org/math/9/2/e/92eb5ffee6ae2fec3ad71c777531578f.png","//upload.wikimedia.org/math/4/a/8/4a8a08f09d37b73795649038408b5f33.png","//upload.wikimedia.org/math/0/c/c/0cc175b9c0f1b6a831c399e269772661.png","//upload.wikimedia.org/math/0/c/c/0cc175b9c0f1b6a831c399e269772661.png","//bits.wikimedia.org/static-1.21wmf10/skins/vector/images/search-ltr.png?303-4","//bits.wikimedia.org/images/wikimedia-button.png","//bits.wikimedia.org/static-1.21wmf10/skins/common/images/poweredby_mediawiki_88x31.png"],"tags":[["scala","programming_language"]],"members":["scala"],"related":["Computing","Programming_paradigm","Dataflow_programming","Spreadsheet","Hardware_description_language","Verilog","Model-view-controller","Functional_reactive_programming","Lazy_evaluation","Observer_pattern","Object-oriented_programming","Multiple_inheritance","Constraint_imperative_programming","OOPic","Functional_reactive_programming","Functional_programming","QML","Software_transactional_memory","EDSL","Stack_Overflow","Scala_(programming_language)"]}
{"cursor":"13288","size":15,"audio":[],"currentlang":"en","article":"\nIn computer science and logic, a 'dependent type' is a type that depends on a\nvalue. Dependent types play a central role in intuitionistic type theory and in\nthe design of functional programming languages like ATS, Agda and Epigram.\n\nAn example is the type of n-tuples of real numbers. This is a dependent type\nbecause the type depends on the value n.\n\nDeciding equality of dependent types in a program may require computations. If\narbitrary values are allowed in dependent types, then deciding type equality may\ninvolve deciding whether two arbitrary programs produce the same result; hence\ntype checking may become undecidable.\n\nThe CurryâHoward correspondence implies that types can be constructed that\nexpress arbitrarily complex mathematical properties. If the user can supply a\nconstructive proof that a type is inhabited (i.e., that a value of that type\nexists) then a compiler can check the proof and convert it into executable\ncomputer code that computes the value by carrying out the construction. The\nproof checking feature makes dependently typed languages closely related to\nproof assistants. The code-generation aspect provides a powerful approach to\nformal program verification and proof-carrying code, since the code is derived\ndirectly from a mechanically verified mathematical proof.\n","linknr":300,"url":"Dependent_type","recorded":1362543949,"links":27,"instances":["programming_language","programming_language","theorem_prover","type_theory","programming_language","programming_language","logical_framework","proof_assistant","mathematics","programming_language"],"pdf":["http://guru-lang.googlecode.com/svn/branches/1.0/doc/book.pdf","http://guru-lang.googlecode.com/svn/branches/1.0/doc/book.pdf","http://www.cs.uiowa.edu/~astump/papers/petcher-thesis.pdf","http://www.cs.uiowa.edu/~astump/papers/petcher-thesis.pdf","http://www.cs.st-andrews.ac.uk/~eb/drafts/ifl08.pdf","http://www.cs.st-andrews.ac.uk/~eb/drafts/ifl08.pdf","http://www.cs.cmu.edu/afs/cs/Web/People/crary/819-f09/Martin-Lof80.pdf","http://www.cs.cmu.edu/afs/cs/Web/People/crary/819-f09/Martin-Lof80.pdf","http://www.cs.nott.ac.uk/~txa/publ/ydtm.pdf","http://www.cs.nott.ac.uk/~txa/publ/ydtm.pdf","http://www.cse.chalmers.se/~ulfn/papers/thesis.pdf","http://www.cs.ru.nl/~wouters/Publications/ThePowerOfPi.pdf","http://www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf"],"categories":["Dependently typed programming|","Type theory"],"headings":["Systems of the lambda cube","Comparison","See also","Footnotes","References","Further reading","External"],"image":["//upload.wikimedia.org/math/d/8/a/d8a56734e6d562e13c4bdc213e273842.png","//upload.wikimedia.org/math/d/0/c/d0c646f870371c156aef306b4100cef0.png","//upload.wikimedia.org/math/7/b/8/7b8b965ad4bca0e41ab51de7b31363a1.png","//upload.wikimedia.org/math/1/9/2/19226d9d5001b7deb8041e43403e2e32.png","//upload.wikimedia.org/math/b/0/1/b010ebf757403bd8530694900bfe0299.png","//upload.wikimedia.org/math/5/6/a/56a514984a84f0101d76c103c8faa0c7.png","//upload.wikimedia.org/math/d/9/f/d9f86c36f9c227990d523a5395cf25b1.png","//upload.wikimedia.org/math/d/8/a/d8a56734e6d562e13c4bdc213e273842.png","//upload.wikimedia.org/math/d/a/5/da558173e1f2ddfeb273751d481f9a52.png","//upload.wikimedia.org/math/d/4/d/d4d49bead125261b226eaa867bd016ce.png","//upload.wikimedia.org/math/5/0/8/5081cf614641415c403a6f0f7bc84e0c.png","//upload.wikimedia.org/math/d/9/f/d9f86c36f9c227990d523a5395cf25b1.png","//bits.wikimedia.org/static-1.21wmf10/skins/vector/images/search-ltr.png?303-4","//bits.wikimedia.org/images/wikimedia-button.png","//bits.wikimedia.org/static-1.21wmf10/skins/common/images/poweredby_mediawiki_88x31.png"],"tags":[["ats","programming_language"],["agda","theorem_prover"],["epigram","programming_language"],["kind","type_theory"],["lf","logical_framework"],["tactic","proof_assistant"],["universe","mathematics"],["agda","theorem_prover"],["ats","programming_language"],["cayenne","programming_language"],["epigram","programming_language"],["f*","programming_language"],["racket","programming_language"]],"members":["racket","ats","agda","kind","epigram","lf","tactic","universe","cayenne"],"related":["Computer_science","Logic","Type_system","Intuitionistic_type_theory","Functional_programming_languages","ATS_(programming_language)","Agda_(theorem_prover)","Epigram_(programming_language)","Type_checking","Undecidable_problem","Curry–Howard_correspondence","Constructive_proof","Proof_assistant","Program_verification","Proof-carrying_code","Henk_Barendregt","Lambda_cube","Simply_typed_lambda_calculus","Calculus_of_constructions","Kind_(type_theory)","Pure_type_system","LF_(logical_framework)","Simply_typed_lambda_calculus","Real_numbers","Natural_number","System_F","Lambda_cube","Calculus_of_constructions","Calculus_of_inductive_constructions","Coq","Object-oriented_programming","Tactic_(proof_assistant)","Proof_term","Termination_checking","Universe_(mathematics)","Proof_irrelevance","Program_extraction","Agda_(theorem_prover)","Purely_functional","ATS_(programming_language)","Cayenne_(programming_language)","Coq","Dependent_ML","Epigram_(programming_language)","Matita","NuPRL","F*_(programming_language)","Prototype_Verification_System","Racket_(programming_language)","Twelf","Logic_programming","Typed_lambda_calculus","Design_by_contract"]}
{"cursor":"12365","size":15,"audio":[],"currentlang":"en","article":"\n:''\"Page size\" redirects to this article. For information on paper see\n:Paper size\n\nA 'page', 'memory page', or 'virtual page' is a fixed-length contiguous block of\nvirtual memory, and it is the smallest unit of data for the following:\n* memory allocation performed by the operating system for a program; and\n* transfer between main memory and any other auxiliary store, such as a hard\n  disk drive.\n\nVirtual memory allows a page that does not currently reside in main memory to be\naddressed and used. If a program tries to access a location in such a page, an\nexception called a page fault is generated. The hardware or operating system is\nnotified and loads the required page from the auxiliary store automatically. A\nprogram addressing the memory has no knowledge of a page fault or a process\nfollowing it. Thus a program can address more (virtual) RAM than physically\nexists in the computer. Virtual memory is a scheme that gives users the illusion\nof working with a large block of contiguous memory space (perhaps even larger\nthan real memory), when in actuality most of their work is on auxiliary storage\n(disk). Fixed-size blocks (pages) or variable-size blocks of the job are read\ninto main memory as needed.\n\nA transfer of pages between main memory and an auxiliary store, such as a hard\ndisk drive, is referred to as paging or swapping. {{Citation\n  | contribution = Virtual memory systems title = Encyclopedia of computer\n  | science and technology editor1-last = Belzer editor1-first = Jack editor2-\n  | last = Holzman editor2-first = Albert G. editor3-last = Kent editor3-first\n  | = Allen publisher = CRC Press volume=14 page = 32 year = 1981 url =\n  | http://books.google.com/books?id=KUgNGCJB4agC&printsec=frontcover isbn =\n  | 0-8247-2214-0 }}\n\n","linknr":203,"url":"Page_(computer_memory)","recorded":1362551504,"links":22,"instances":["programming_language","operating_system"],"pdf":["http://static.usenix.org/publications/library/proceedings/usenix98/full_papers/ganapathy/ganapathy.pdf","http://static.usenix.org/publications/library/proceedings/usenix98/full_papers/ganapathy/ganapathy.pdf","http://www.sun.com/blueprints/0304/817-5917.pdf","http://www.sun.com/blueprints/0304/817-5917.pdf","http://www.sun.com/blueprints/0304/817-6242.pdf","http://www.sun.com/blueprints/0304/817-6242.pdf"],"categories":["Articles with example C code","Central processing unit","Memory management"],"headings":["Page size trade-off","Determining the page size in a program","Huge pages","See also","References","Further reading"],"image":["//upload.wikimedia.org/wikipedia/en/thumb/f/f2/Edit-clear.svg/40px-Edit-clear.svg.png","//bits.wikimedia.org/static-1.21wmf10/skins/vector/images/search-ltr.png?303-4","//bits.wikimedia.org/images/wikimedia-button.png","//bits.wikimedia.org/static-1.21wmf10/skins/common/images/poweredby_mediawiki_88x31.png"],"tags":[["c","programming_language"],["solaris","operating_system"]],"members":["c","solaris"],"related":["Paper_size","Virtual_memory","Memory_allocation","Hard_disk_drive","Page_fault","Paging","Byte","Page_table","Translation_Lookaside_Buffer","Unix","POSIX","C_(programming_language)","Win32","Windows_9x","Windows_NT","Instruction_set_architecture","Pentium_Pro","X86","Page_Size_Extension","Physical_Address_Extension","X86-64","AMD","Intel","Intel_Westmere","Long_mode","IA-64","FreeBSD","Microsoft_Windows","Personal_computer","High-performance_computing","SGI_IRIX","Linux","Windows_Server_2003","Windows_Vista","Windows_Server_2008","Windows_2000","Windows_XP","Solaris_(operating_system)","SPARC","Virtual_memory","Page_table","Paging","Page_fault","Springer_Science+Business_Media"]}
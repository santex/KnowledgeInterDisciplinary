{"cursor":"11252","size":15,"audio":[],"currentlang":"en","article":"In computing, 'inline expansion', or 'inlining', is a manual or compiler\noptimization that replaces a function call site with the body of the callee.\nThis optimization may improve time and space usage at runtime, at the possible\ncost of increasing the final size of the program (i.e. the binary file size).\n\nOrdinarily, when a function is invoked, control is transferred to its definition\nby a branch or call instruction. With inlining, control drops through directly\nto the code for the function, without a branch or call instruction. Inlining\nimproves performance in several ways:\n* It removes the cost of the function call and return instructions, as well\n  as any other prologue and epilogue code injected into every function by\n  the compiler.\n* Eliminating branches and keeping code that is executed close together in\n  memory improves instruction cache performance by improving locality of\n  reference.\n* Once inlining has been performed, additional intraprocedural optimizations\n  become possible on the inlined function body. For example, a constant passed\n  as an argument, can often be propagated to all instances of the matching\n  parameter, or part of the function may be \"hoisted out\" of a loop.\n\nThe primary cost of inlining is that it tends to increase code size, although\nit does not always do so. Inlining may also decrease performance in some\ncases â for instance, multiple copies of a function may increase code\nsize enough that the code no longer fits in the cache, resulting in more\ncache misses.\n\nSome languages (for example, C and C++) support the inline keyword\nin function definitions. This keyword serves as a \"hint\" to the compiler\nthat it should try to inline the function. Compilers use a variety of\nmechanisms, including hints from programmers, to decide which function calls\nshould be inlined.\n\nCompilers usually implement statements with inlining. Loop conditions and loop\nbodies need lazy evaluation. This property is fulfilled when the code to compute\nloop conditions and loop bodies is inlined. Performance considerations are\nanother reason to inline statements.\n\nIn the context of functional programming languages, inline expansion is usually\nfollowed by the beta-reduction transformation.\n\nA programmer might inline a function manually through copy and paste\nprogramming, as a one-time operation on the source code. However, other methods\nof controlling inlining (see below) are preferable, because they do not\nprecipitate bugs arising when the programmer overlooks a (possibly modified)\nduplicated version of the original function body, while fixing a bug in the\ninlined function.\n","linknr":174,"url":"Inline_expansion","recorded":1362575811,"links":13,"instances":["computer_science","mathematics","computer_science","programming_language","computer_science","computer_science","computing","program_lifecycle_phase","computer_science"],"pdf":[],"categories":["Compiler optimizations","Articles with example C code","Subroutines"],"headings":["Implementation","Benefits","0</code> to <code>y","Problems","Limitations","Selection methods and language support","See also","External links","References"],"image":["//upload.wikimedia.org/wikipedia/commons/thumb/f/f8/Wiktionary-logo-en.svg/37px-Wiktionary-logo-en.svg.png","//bits.wikimedia.org/static-1.21wmf10/skins/vector/images/search-ltr.png?303-4","//bits.wikimedia.org/images/wikimedia-button.png","//bits.wikimedia.org/static-1.21wmf10/skins/common/images/poweredby_mediawiki_88x31.png"],"tags":[["branch","computer_science"],["constant","programming"],["c","computer_language"],["statement","computer_science"],["linker","computing"],["run_time","program_lifecycle_phase"],["c","programming_language"],["constant","mathematics"],["optimization","computer_science"],["thrashing","computer_science"],["linker","computing"],["macro","computer_science"]],"members":["optimization","constant","branch","c","statement","thrashing","linker","run_time","macro"],"related":["Computing","Compiler_optimization","Call_site","Callee","Binary_file","Control_flow","Branch_(computer_science)","Algorithmic_efficiency","Function_call","Return_statement","Function_prologue","Instruction_cache","Locality_of_reference","Constant_(programming)","Loop-invariant_code_motion","C_(computer_language)","C++","Compiler","Compiler","Statement_(computer_science)","Lazy_evaluation","Functional_programming_language","Lambda_calculus","Copy_and_paste_programming","Source_code","Compiler","Intermediate_representation","Abstract_syntax_tree","Parameter","Linker_(computing)","Link-time_optimization","Run-time_system","Run_time_(program_lifecycle_phase)","Java_Hotspot_compiler","C_(programming_language)","Parameterized_macro","Inline_function","Subroutine","Enabling_transformation","Constant_(mathematics)","Conditional_branch","Dead_code_elimination","Loop-invariant_code_motion","Induction_variable_elimination","Algorithmic_efficiency","Optimization_(computer_science)","Embedded_system","Mutator_method","CPU_cache","Processor_register","Register_pressure","Thrashing_(computer_science)","Embedded_system","Heuristics","Computer_peripheral","Executable","Functional_programming","Object-oriented_programming_language","Inline_function","Algorithmic_efficiency","Linker_(computing)","Macro_(computer_science)","Partial_evaluation","Gerald_Aigner","Urs_Hölzle","Brad_Calder","Dirk_Grumwald","Simon_Peyton_Jones","Simon_Marlow","John_R._Levine","Henry_G._Baker","Brandon_Bray"]}
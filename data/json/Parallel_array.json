{"cursor":"5493","size":15,"audio":[],"currentlang":"en","article":"In computing, a 'parallel array' is a data structure for representing arrays of\nrecords. It keeps a separate, homogeneous array for each field of the record,\neach having the same number of elements. Then, objects located at the same index\nin each array are implicitly the fields of a single record. Pointers from one\nobject to another are replaced by array indices. This contrasts with the normal\napproach of storing all fields of each record together in memory. For example,\none might declare an array of 100 names, each a string, and 100 ages, each an\ninteger, associating each name with the age that has the same index.\n\nAn example in C using parallel arrays:\n\n int ages[] = {0, 17, 2, 52, 25}; char *names[] = {\"None\",\n\"Mike\", \"Billy\", \"Tom\", \"Stan\"}; int parent[] = {0 /*None*/, 3 /*Tom*/, 1\n/*Mike*/, 0 /*None*/, 3 /*Tom*/};\n\nfor(i = 1; i  in Perl (using a hash of arrays to hold\nreferences to each array):  my %data = ( first_name =>\n['Joe', 'Bob', 'Frank', 'Hans' ], last_name =>\n['Smith','Seger','Sinatra','Schultze'], height_in_cm => [169, 158, 201, 199 ]);\n\nfor $i (0..$#{$data{first_name}}) { printf \"Name: %s %s\\n\",\n$data{first_name}[$i], $data{last_name}[$i]; printf \"Height in CM: %i\\n\",\n$data{height_in_cm}[$i]; }  Or, in Python: \nfirstName = ['Joe', 'Bob', 'Frank', 'Hans' ] lastName =\n['Smith','Seger','Sinatra','Schultze'] heightInCM = [169, 158, 201, 199 ]\n\nfor i in xrange(len(firstName)): print \"Name: %s %s\" % (firstName[i],\nlastName[i]) print \"Height in CM: %s\" % heightInCM[i] \n\nParallel arrays have a number of practical advantages over the normal approach:\n* They can be used in languages which support only arrays of primitive types and\n  not of records (or perhaps don't support records at all).\n* Parallel arrays are simple to understand and use, and are often used where\n  declaring a record is more trouble than it's worth.\n* They can save a substantial amount of space in some cases by avoiding\n  alignment issues. For example, one of the fields of the record can be a single\n  bit, and its array would only need to reserve one bit for each record, whereas\n  in the normal approach many more bits would \"pad\" the field so that it\n  consumes an entire byte or a word.\n* If the number of items is small, array indices can occupy significantly less\n  space than full pointers, particularly on architectures with large words.\n* Sequentially examining a single field of each record in the array is very fast\n  on modern machines, since this amounts to a linear traversal of a single\n  array, exhibiting ideal locality of reference and cache behavior.\n\nHowever, parallel arrays also have several strong disadvantages, which serves to\nexplain why they are not generally preferred:\n\n* They have significantly worse locality of reference when visiting the records\n  sequentially and examining multiple fields of each record, which is the norm.\n* They obscure the relationship between fields of a single record.\n* They have little direct language support (the language and its syntax\n  typically express no relationship between the arrays in the parallel array).\n* They are expensive to grow or shrink, since each of several arrays must\n  be reallocated. Multi-level arrays can ameliorate this problem, but\n  impacts performance due to the additional indirection needed to find the\n  desired elements.\n\nThe bad locality of reference is the worst issue. However, a compromise can be\nmade in some cases: if a structure can be divided into groups of fields that are\ngenerally accessed together, an array can be constructed for each group, and its\nelements are records containing only these subsets of the larger structure's\nfields. This is a valuable way of speeding up access to very large structures\nwith many members, while keeping the portions of the structure tied together. An\nalternative to tying them together using array indexes is to use references to\ntie the portions together, but this can be less efficient in time and space.\nAnother alternative is to mock up a record structure in a single-dimensional\narray by declaring an array of n*m size and referring to the r-th field in\nrecord i as element as array(m*i+r). Some compiler optimizations, particularly\nfor vector processors, are able to perform this transformation automatically\nwhen arrays of structures are created in the program.\n","linknr":98,"url":"Parallel_array","recorded":1362540259,"links":12,"instances":["programming_language","computer_science","computer_science"],"pdf":[],"categories":["Arrays","Articles with example C code","Articles with example Perl code","Articles with example Python code"],"headings":["See also","References"],"image":["//bits.wikimedia.org/static-1.21wmf10/skins/vector/images/search-ltr.png?303-4","//bits.wikimedia.org/images/wikimedia-button.png","//bits.wikimedia.org/static-1.21wmf10/skins/common/images/poweredby_mediawiki_88x31.png"],"tags":[["record","computer_science"],["c","programming_language"],["reference","computer_science"]],"members":["c","reference","record"],"related":["Computing","Data_structure","Array_data_structure","Record_(computer_science)","C_(programming_language)","Perl","Python_Programming_Language","Locality_of_reference","Reference_(computer_science)","Compiler_optimization","Vector_processor","Column-oriented_DBMS","Thomas_H._Cormen","Charles_E._Leiserson","Ronald_L._Rivest","Clifford_Stein"]}
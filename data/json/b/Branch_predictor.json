{"cursor":"28048","size":15,"audio":[],"currentlang":"en","article":"\n\nIn computer architecture, a 'branch predictor' is a digital circuit that tries\nto guess which way a branch (e.g. an if-then-else structure) will go before this\nis known for sure. The purpose of the branch predictor is to improve the flow in\nthe instruction pipeline. Branch predictors play a critical role in achieving\nhigh effective performance in many modern pipelined microprocessor architectures\nsuch as x86.\n\nTwo-way branching is usually implemented with a conditional jump instruction. A\nconditional jump can either be \"not taken\" and continue execution with the first\nbranch of code which follows immediately after the conditional jump - or it can\nbe \"taken\" and jump to a different place in program memory where the second\nbranch of code is stored.\n\n\nIt is not known for certain whether a conditional jump will be taken or not\ntaken until the condition has been calculated and the conditional jump has\npassed the execution stage in the instruction pipeline (see fig. 1).\n\nWithout branch prediction, the processor would have to wait until the\nconditional jump instruction has passed the execute stage before the next\ninstruction can enter the fetch stage in the pipeline. The branch predictor\nattempts to avoid this waste of time by trying to guess whether the conditional\njump is most likely to be taken or not taken. The branch that is guessed to be\nthe most likely is then fetched and speculatively executed. If it is later\ndetected that the guess was wrong then the speculatively executed or partially\nexecuted instructions are discarded and the pipeline starts over with the\ncorrect branch, incurring a delay.\n\nThe time that is wasted in case of a branch misprediction is equal to the number\nof stages in the pipeline from the fetch stage to the execute stage. Modern\nmicroprocessors tend to have quite long pipelines so that the misprediction\ndelay is between 10 and 20 clock cycles. The longer the pipeline the greater the\nneed for a good branch predictor.\n\nThe first time a conditional jump instruction is encountered, there is not much\ninformation to base a prediction on. But the branch predictor keeps records of\nwhether branches are taken or not taken. When it encounters a conditional jump\nthat has been seen several times before then it can base the prediction on the\nhistory. The branch predictor may, for example, recognize that the conditional\njump is taken more often than not, or that it is taken every second time.\n\nBranch prediction is not the same as branch target prediction. Branch prediction\nattempts to guess whether a conditional jump will be taken or not. Branch target\nprediction attempts to guess the target of a taken conditional or unconditional\njump before it is computed by decoding and executing the instruction itself.\nBranch prediction and branch target prediction are often combined into the same\ncircuitry.\n","linknr":286,"url":"Branch_predictor","recorded":1362484662,"links":27,"instances":["brand","computing","computer_science","microprocessor","p5_microarchitecture","programming"],"pdf":["http://webspace.ulbsibiu.ro/lucian.vintan/html/USA.pdf","http://cava.cs.utsa.edu/pdfs/micro03_dist.pdf","http://www.hpl.hp.com/techreports/Compaq-DEC/WRL-TN-36.pdf"],"categories":["Instruction processing"],"headings":["Implementation","History","See also","References","External links"],"image":["//upload.wikimedia.org/wikipedia/commons/thumb/c/cb/Pipeline%2C_4_stage.svg/375px-Pipeline%2C_4_stage.svg.png","//bits.wikimedia.org/static-1.21wmf10/skins/common/images/magnify-clip.png","//upload.wikimedia.org/wikipedia/commons/thumb/c/c8/Branch_prediction_2bit_saturating_counter-dia.svg/600px-Branch_prediction_2bit_saturating_counter-dia.svg.png","//bits.wikimedia.org/static-1.21wmf10/skins/common/images/magnify-clip.png","//upload.wikimedia.org/wikipedia/commons/thumb/c/ce/Two-level_branch_prediction.svg/420px-Two-level_branch_prediction.svg.png","//bits.wikimedia.org/static-1.21wmf10/skins/common/images/magnify-clip.png","//bits.wikimedia.org/static-1.21wmf10/skins/vector/images/search-ltr.png?303-4","//bits.wikimedia.org/images/wikimedia-button.png","//bits.wikimedia.org/static-1.21wmf10/skins/common/images/poweredby_mediawiki_88x31.png"],"tags":[["branch","computer_science"],["conditional","programming"],["pipeline","computing"],["branch","computer_science"],["original_intel_pentium","p5_microarchitecture"],["r2000","microprocessor"],["pentium","brand"]],"members":["pentium","pipeline","branch","r2000","original_intel_pentium","conditional"],"related":["Computer_architecture","Digital_electronics","Branch_(computer_science)","Conditional_(programming)","Instruction_pipeline","Computer_performance","Pipeline_(computing)","Microprocessor","X86","Branch_(computer_science)","Speculative_execution","Clock_cycle","Branch_target_predictor","SPARC","MIPS_architecture","RISC","Branch_delay_slot","Pentium_4","Pentium_4","Superscalar","R8000","Alpha_21264","Alpha_21464","Branch_target_predictor","Delay_slot","State_machine","Original_Intel_Pentium_(P5_microarchitecture)","SPEC","Memory_address","Shift_register","Binary_numeral_system","Subsequence","Yale_Patt","Intel","Pentium_MMX","Pentium_II","Pentium_III","SPEC","Correlation","Exponential_function","XOR_gate","Concatenation","Advanced_Micro_Devices","Pentium_M","Intel_core","Intel_core_2","Concatenation","VIA_Nano","Pentium_4","Scott_McFarling","Indirect_branch","Subroutine","Return_statement","Call_stack","Trade-off","Intel_Core_i7","Branch_target_predictor","Dynamic_neural_branch_predictor","Lucian_Blaga_University_of_Sibiu","Romania","Rutgers_University","Perceptron","IA-64","IBM_Stretch","Burroughs_B2500","VAX_9000","MIPS_Technologies","R2000_(microprocessor)","R3000","SPARC","R4000","Pentium_(brand)","Alpha_21064","R8000","IBM_POWER","Alpha_21264","AMD_K8","Alpha_21464","Branch_target_predictor","Branch_prediction_analysis_attacks","Public-key_cryptography","Instruction_unit"]}
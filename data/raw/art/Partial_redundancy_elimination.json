{"cursor":"3545","size":15,"audio":[],"currentlang":"en","article":"In compiler theory, 'partial redundancy elimination' (PRE) is a compiler\noptimization that eliminates expressions that are redundant on some but not\nnecessarily all paths through a program. PRE is a form of common subexpression\nelimination.\n\nAn expression is called partially redundant if the value computed by the\nexpression is already available on some but not all paths through a program to\nthat expression. An expression is fully redundant if the value computed by the\nexpression is available on all paths through the program to that expression. PRE\ncan eliminate partially redundant expressions by inserting the partially\nredundant expression on the paths that do not already compute it, thereby making\nthe partially redundant expression fully redundant.\n\nFor instance, in the following code:  if (some_condition) { //\nsome code y = x + 4; } else { // other code } z = x + 4;  the\nexpression x+4 assigned to z is partially redundant\nbecause it is computed twice if some_condition is true. PRE would\nperform code motion on the expression to yield the following optimized code:\n if (some_condition) { // some code t = x + 4; y = t; } else {\n// other code t = x + 4; } z = t;  An interesting property of PRE is\nthat it performs (a form of) common subexpression elimination and loop-invariant\ncode motion at the same time. In addition, PRE can be extended to eliminate\ninjured partial redundancies, thereby effectively performing strength reduction.\nThis makes PRE one of the most important optimizations in optimizing compilers.\nTraditionally, PRE is applied to lexically equivalent expressions, but recently\nformulations of PRE based on static single assignment form have been published\nthat apply the PRE algorithm to values instead of expressions, unifying PRE and\nglobal value numbering.\n","linknr":79,"url":"Partial_redundancy_elimination","recorded":1362897031,"links":10,"instances":["computer_science","programming"],"pdf":[],"categories":["Compiler optimizations","Articles with example code"],"headings":["Further reading"],"image":["//bits.wikimedia.org/static-1.21wmf10/skins/vector/images/search-ltr.png?303-4","//bits.wikimedia.org/images/wikimedia-button.png","//bits.wikimedia.org/static-1.21wmf10/skins/common/images/poweredby_mediawiki_88x31.png"],"tags":[["expression","programming"],["value","computer_science"]],"members":["value","expression"],"related":["Compiler_theory","Compiler_optimization","Expression_(programming)","Common_subexpression_elimination","Value_(computer_science)","Code_motion","Common_subexpression_elimination","Loop-invariant_code_motion","Strength_reduction","Static_single_assignment_form","Global_value_numbering"]}
{"cursor":"16221","size":15,"audio":[],"currentlang":"en","article":"\n\n\n\nIn computability theory, a system of data-manipulation rules (such as a\ncomputer's instruction set, a programming language, or a cellular automaton) is\nsaid to be 'Turing complete' or 'computationally universal' if it can be used to\nsimulate any single-taped Turing machine. A classic example is the lambda\ncalculus. The concept is named after Alan Turing.\n\nComputability theory includes the closely related concept of Turing equivalence.\nTwo computers P and Q are called Turing equivalent if P can simulate Q and Q can\nsimulate P. Thus, a Turing-complete system is one that can simulate a Turing\nmachine; and, per the Church-Turing thesis, that any real-world computer can be\nsimulated by a Turing machine, it is Turing equivalent to a Turing machine.\n\nIn colloquial usage, the terms \"Turing complete\" or \"Turing equivalent\" are used\nto mean that any real-world general-purpose computer or computer language can\napproximately simulate any other real-world general-purpose computer or computer\nlanguage. However, within the bounds of finite memory, they are only linear\nbounded automaton complete. Also, any physical computing device has a finite\nlifespan. In contrast, a universal computer is defined as a device with a Turing\ncomplete instruction set, infinite memory, and an infinite lifespan.\n\nTo show that something is Turing complete, it is enough to show that it can be\nused to simulate some Turing complete system. For example, an imperative\nlanguage is Turing complete if it has conditional branching (e.g., \"if\" and\n\"goto\" statements, or a \"branch if zero\" instruction. See OISC) and the ability\nto change arbitrary memory locations (e.g., the ability to maintain an\narbitrary number of variables). Since this is almost always the case, most if\nnot all imperative languages are Turing complete if we ignore any limitations\nof finite memory.\n","linknr":267,"url":"Turing_equivalence_(theory_of_computation)","recorded":1362539280,"links":32,"instances":["programming_language","programming_language","programming_language","computer_science","computing","programming_language","programming_language","computer","programming_language","programming_language"],"pdf":["http://www.comlab.ox.ac.uk/activities/ieg/e-library/sources/tp2-ie.pdf","http://www.comlab.ox.ac.uk/activities/ieg/e-library/sources/tp2-ie.pdf"],"categories":["Theory of computation","Turing machine","Programming language theory"],"headings":["Formal definitions","History","Computability theory","Turing oracles","Digital physics","Examples","Non-Turing-complete languages","See also","References","External links"],"image":["//upload.wikimedia.org/wikipedia/en/thumb/9/99/Question_book-new.svg/50px-Question_book-new.svg.png","//bits.wikimedia.org/static-1.21wmf10/skins/vector/images/search-ltr.png?303-4","//bits.wikimedia.org/images/wikimedia-button.png","//bits.wikimedia.org/static-1.21wmf10/skins/common/images/poweredby_mediawiki_88x31.png"],"tags":[["computability_theory","computation"],["z3","computer"],["pascal","programming_language"],["java","programming_language"],["ada","programming_language"],["lisp","programming_language"],["haskell","programming_language"],["charity","programming_language"],["epigram","programming_language"],["loop","programming_language"],["loop","computing"],["computability_theory","computer_science"]],"members":["charity","java","lisp","computability_theory","loop","pascal","epigram","z3","ada","haskell"],"related":["Computability_theory","Instruction_set","Programming_language","Cellular_automaton","Turing_machine","Lambda_calculus","Alan_Turing","Computability_theory","Turing_equivalence","Church-Turing_thesis","Linear_bounded_automaton","Universal_computer","Imperative_language","Conditional_branching","One_instruction_set_computer","Computer_memory","Computability_theory_(computation)","Abstract_machine","Programming_language","Computable_function","Universal_Turing_machine","Turing_machine","Church–Turing_thesis","Cellular_automaton","Turing_machine","Universal_Turing_machine","Church–Turing_thesis","Computer","Computer_program","Charles_Babbage","Analytical_engine","Leopold_Kronecker","Primitive_recursive_functions","David_Hilbert","Kurt_Gödel","Gödel's_completeness_theorem","Gödel's_incompleteness_theorem","General_recursive_functions","John_von_Neumann","Z3_(computer)","Konrad_Zuse","ENIAC","Halting_problem","Cantor's_diagonal_argument","Halting_problem","Turing_oracle","Digital_physics","Universe","Theoretical_computer_science","Automata_theory","Universal_Turing_machine","Lambda_calculus","Formal_grammar","Formal_language","Rewrite_system","Post–Turing_machine","Programming_language","Procedural_programming","Pascal_(programming_language)","Object-oriented_programming_language","Java_(programming_language)","Smalltalk","Multi-paradigm_programming_language","Ada_(programming_language)","C++","Common_Lisp","Object_Pascal","Functional_programming","Lisp_(programming_language)","Haskell_(programming_language)","Logic_programming","Prolog","Declarative_programming","XSLT","Esoteric_programming_language","Mathematical_recreation","Fortran","Goto","Recursion","SQL","Lambda_calculus","System_F","Rule_110","Conway's_Game_of_Life","Cellular_automaton","Regular_language","Regular_expression","Finite_state_machine","Pushdown_automaton","Context-free_grammar","Compiler","Direct3D","OpenGL","Spreadsheet","Total_functional_programming","Charity_(programming_language)","Epigram_(programming_language)","Category_theory","Dependent_type","LOOP_(programming_language)","Primitive_recursive_function","XML","JSON","YAML","S-expression","Markup_language","Loop_(computing)","Inner_loop","Smn_theorem","Church–Turing_thesis","Computability_theory_(computer_science)","Algorithmic_information_theory","Chomsky_hierarchy","Machines_that_always_halt","Stephen_Wolfram","Principle_of_Computational_Equivalence","Turing_tarpit","Structured_program_theorem","Lawrence_Landweber","Rolf_Herken"]}
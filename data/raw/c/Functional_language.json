{"cursor":"50689","size":15,"audio":["//upload.wikimedia.org/wikipedia/commons/8/83/En-Functional_programming.ogg"],"currentlang":"en","article":"\n\n\nIn computer science, 'functional programming' is a programming paradigm that\ntreats computation as the evaluation of mathematical functions and avoids state\nand mutable data. It emphasizes the application of functions, in contrast to the\nimperative programming style, which emphasizes changes in state. Functional programming has its roots in lambda calculus,\na formal system developed in the 1930s to investigate computability, the\nEntscheidungsproblem, function definition, function application, and recursion.\nMany functional programming languages can be viewed as elaborations on the\nlambda calculus.\n\nIn practice, the difference between a mathematical function and the notion of a\nfunction used in imperative programming is that imperative functions can have\nside effects that may change the value of program state. Because of this, they\nlack referential transparency, i.e. the same language expression can result in\ndifferent values at different times depending on the state of the executing\nprogram. Conversely, in functional code, the output value of a function depends\nonly on the arguments that are input to the function, so calling a function f\ntwice with the same value for an argument x will produce the same result f(x)\nboth times. Eliminating side effects can make it much easier to understand and\npredict the behavior of a program, which is one of the key motivations for the\ndevelopment of functional programming.\n\nFunctional programming languages, especially purely functional ones such as the\npioneering Hope, have largely been emphasized in academia rather than in\ncommercial software development. However, prominent functional programming\nlanguages such as Common Lisp, Scheme, ISLISP,\nClojure, Racket, Erlang, OCaml, Haskell, Scala and F# have been used in\nindustrial and commercial applications by a wide variety of organizations.\nFunctional programming is also supported in some domain-specific programming\nlanguages like R (statistics),\nMathematica (symbolic and numeric math), J, K and Q from\nKx Systems (financial analysis), XQuery/XSLT (XML) and Opal. Widespread domain-\nspecific declarative languages like SQL and Lex/Yacc use some elements of\nfunctional programming, especially in eschewing mutable values.\n\nProgramming in a functional style can also be accomplished in languages that\naren't specifically designed for functional programming. For example, the\nimperative Perl programming language has been the subject of a book describing\nhow to apply functional programming concepts. C# 3.0 added constructs\nto facilitate the functional style.\n","linknr":853,"url":"Functional_language","recorded":1362676846,"links":73,"instances":["programming_language","computer_scientist","computer_science","programming_language","mathematics","programming_language","computer_science","programming_language","programming_language","functional_programming","programming_language","computer_science","programming_language","computer_science","programming_language","programming_language","programming_language","programming_language","programming_language","programming_language","programming_language","programming_language","programming_language_from_kx_systems","programming_language","computer_science","mathematics","programming_language","programming_language","programming_language","programming_language","programming_language","programming_language","computer_scientist","theorem_prover","design_pattern","programming_language","computer_scientist","programming_language","programming_language","computer_science","programming_language","programming_language","software"],"pdf":["http://www.cs.berkeley.edu/~jcondit/pl-prelim/hudak89functional.pdf","http://www.cs.berkeley.edu/~jcondit/pl-prelim/hudak89functional.pdf","http://www.gameenginebook.com/gdc09-statescripting-uncharted2.pdf","http://www.gameenginebook.com/gdc09-statescripting-uncharted2.pdf","http://cufp.galois.com/2007/slides/XavierLeroy.pdf","http://cufp.galois.com/2007/slides/XavierLeroy.pdf","http://www.stanford.edu/class/cs242/readings/backus.pdf","http://www.cs.cmu.edu/~rwh/plbook/book.pdf","http://www.cs.cmu.edu/~rwh/plbook/book.pdf","http://research.microsoft.com/~akenn/generics/gadtoop.pdf","http://research.microsoft.com/~akenn/generics/gadtoop.pdf","http://www.ub.utwente.nl/webdocs/ctit/1/00000084.pdf","http://www.ub.utwente.nl/webdocs/ctit/1/00000084.pdf","http://cufp.galois.com/2006/slides/SteveSims.pdf","http://cufp.galois.com/2006/slides/SteveSims.pdf"],"categories":["Programming paradigms","Functional programming|"],"headings":["History","Concepts","Comparison to imperative programming","Use in industry","See also","References","Further reading","External links"],"image":["//upload.wikimedia.org/math/1/1/4/1140b8095b48ecf78f052a86c1afe555.png","//upload.wikimedia.org/math/8/f/a/8fa14cdd754f91cc6554c9e71929cce7.png","//upload.wikimedia.org/wikipedia/en/f/f4/Ambox_content.png","//upload.wikimedia.org/wikipedia/commons/thumb/4/47/Sound-icon.svg/45px-Sound-icon.svg.png","//upload.wikimedia.org/wikipedia/commons/thumb/4/47/Sound-icon.svg/15px-Sound-icon.svg.png","//bits.wikimedia.org/static-1.21wmf10/skins/vector/images/search-ltr.png?303-4","//bits.wikimedia.org/images/wikimedia-button.png","//bits.wikimedia.org/static-1.21wmf10/skins/common/images/poweredby_mediawiki_88x31.png"],"tags":[["function","mathematics"],["side_effect","computer_science"],["referential_transparency","computer_science"],["hope","programming_language"],["lisp","programming_language"],["scheme","programming_language"],["racket","programming_language"],["erlang","programming_language"],["haskell","programming_language"],["scala","programming_language"],["f_sharp","programming_language"],["r","programming_language"],["j","programming_language"],["k","programming_language"],["q","programming_language_from_kx_systems"],["lex","software"],["c_sharp","programming_language"],["lisp","programming_language"],["john_mccarthy","computer_scientist"],["scheme","programming_language"],["dylan","programming_language"],["apl","programming_language"],["fp","programming_language"],["j","programming_language"],["arthur_whitney","computer_scientist"],["k","programming_language"],["q","programming_language_from_kx_systems"],["fp","programming_language"],["ml","programming_language"],["david_turner","computer_scientist"],["sasl","programming_language"],["miranda","programming_language"],["scheme","programming_language"],["haskell","programming_language"],["side_effect","computer_science"],["referential_transparency","computer_science"],["deforestation","computer_science"],["recursion","computer_science"],["recursion","computer_science"],["scheme","programming_language"],["miranda","programming_language"],["clean","programming_language"],["haskell","programming_language"],["agda","theorem_prover"],["cayenne","programming_language"],["epigram","programming_language"],["c","programming_language"],["scala","programming_language"],["d","programming_language"],["python","programming_language"],["c_sharp","programming_language"],["java","programming_language"],["closure","computer_science"],["closure","computer_science"],["design_pattern","computer_science"],["visitor","design_pattern"],["fold","higher-order_function"],["side_effect","computer_science"],["referential_transparency","computer_science"],["haskell","programming_language"],["monad","functional_programming"],["c","programming_language"],["pascal","programming_language"],["clean","programming_language"],["matrix","mathematics"],["j","programming_language"],["k","programming_language"],["haskell","programming_language"],["recursion","computer_science"],["erlang","programming_language"],["erlang","programming_language"],["scheme","programming_language"],["lisp","programming_language"],["haskell","programming_language"],["scala","programming_language"],["f_sharp","programming_language"],["lisp","programming_language"],["opal","programming_language"]],"members":["sasl","arthur_whitney","closure","d","matrix","j","side_effect","k","haskell","monad","cayenne","fold","recursion","dylan","design_pattern","ml","scheme","clean","f_sharp","miranda","c","epigram","opal","q","c_sharp","deforestation","function","r","fp","hope","lisp","pascal","scala","david_turner","agda","visitor","apl","john_mccarthy","python","java","referential_transparency","erlang","racket","lex"],"related":["Computer_science","Programming_paradigm","Computation","Function_(mathematics)","Program_state","Immutable_object","Imperative_programming","Lambda_calculus","Formal_system","Computability","Entscheidungsproblem","Recursion","Programming_language","Side_effect_(computer_science)","Referential_transparency_(computer_science)","Purely_functional","Hope_(programming_language)","Academic","Common_Lisp","Lisp_(programming_language)","Scheme_(programming_language)","ISLISP","Clojure","Racket_(programming_language)","Erlang_(programming_language)","OCaml","Haskell_(programming_language)","Scala_(programming_language)","F_Sharp_(programming_language)","Domain-specific_programming_language","R_(programming_language)","Mathematica","J_(programming_language)","K_(programming_language)","Q_(programming_language_from_Kx_Systems)","XQuery","XSLT","XML","SQL","Lex_(software)","Yacc","Mutable_object","Perl","C_Sharp_(programming_language)","Lambda_calculus","Combinatory_logic","Foundations_of_mathematics","Lisp_(programming_language)","John_McCarthy_(computer_scientist)","Massachusetts_Institute_of_Technology","Scheme_(programming_language)","Dylan_(programming_language)","Information_Processing_Language","Herbert_A._Simon","Logic_Theorist","Kenneth_E._Iverson","APL_(programming_language)","John_Backus","FP_(programming_language)","Roger_Hui","J_(programming_language)","Arthur_Whitney_(computer_scientist)","K_(programming_language)","Q_(programming_language_from_Kx_Systems)","John_Backus","FP_(programming_language)","Turing_Award","Von_Neumann_architecture","Principle_of_compositionality","Function-level_programming","ML_(programming_language)","Robin_Milner","University_of_Edinburgh","David_Turner_(computer_scientist)","SASL_(programming_language)","University_of_St._Andrews","Miranda_(programming_language)","University_of_Kent","OCaml","Standard_ML","Scheme_(programming_language)","Lambda_Papers","Per_Martin-Löf","Intuitionistic_type_theory","Constructive_proof","Dependent_type","Interactive_theorem_proving","Haskell_(programming_language)","Open_standard","Imperative_programming","Object-oriented_programming","Higher-order_function","Differential_operator","Derivative","First-class_function","Partial_application","Currying","Purely_functional","Side_effect_(computer_science)","Referential_transparency_(computer_science)","Memoization","Parallelization","Thread-safe","Deforestation_(computer_science)","GNU_Compiler_Collection","Fortran_95","Iteration","Recursion","Recursion_(computer_science)","Recursion_(computer_science)","Tail_recursion","Scheme_(programming_language)","Continuation_passing_style","Catamorphism","Anamorphism","Program_loops","Imperative_languages","Turing_complete","Halting_problem","Undecidable_problem","Equational_reasoning","Inconsistency","Type_system","Coq","Well-founded","Strongly_normalizing","Codata","Total_functional_programming","Denotational_semantics","Graph_reduction","Miranda_(programming_language)","Clean_(programming_language)","Haskell_(programming_language)","Separation_of_concerns","Operational_semantics","Hindley–Milner_type_inference","Typed_lambda_calculus","Untyped_lambda_calculus","Algebraic_datatypes","Pattern_matching","Type_inference","Coq","Agda_(theorem_prover)","Cayenne_(programming_language)","Epigram_(programming_language)","Intuitionistic_type_theory","Dependent_type","Predicate_logic","Curry–Howard_isomorphism","Mathematical_proof","Formal_verification","Formalized_mathematics","Compcert","Compiler","C_(programming_language)","Generalized_algebraic_data_type","Glasgow_Haskell_Compiler","Scala_(programming_language)","D_(programming_language)","Fortran_95","Python_(programming_language)","Guido_van_Rossum","PHP","Visual_Basic","C_Sharp_(programming_language)","C++11","Language_Integrated_Query",".NET_Framework","Java_(programming_language)","Anonymous_class","Closure_(computer_science)","Closure_(computer_science)","Object-oriented","Design_pattern_(computer_science)","Strategy_pattern","Visitor_(design_pattern)","Catamorphism","Fold_(higher-order_function)","Imperative_programming","Side_effect_(computer_science)","Referential_transparency_(computer_science)","Haskell_(programming_language)","Monad_(functional_programming)","Category_theory","Data_structure","State-passing_style","Clojure","Hoare_logic","Uniqueness_type","Effect_system","Central_processing_unit","C_(programming_language)","Pascal_(programming_language)","OCaml","Clean_(programming_language)","Matrix_(mathematics)","Database","Array_programming","J_(programming_language)","K_(programming_language)","Inline_expansion","Lazy_evaluation","Fibonacci_number","C++","Haskell_(programming_language)","Program_loops","Recurrence_relation","Recursion_(computer_science)","Lazy_evaluation","Erlang_(programming_language)","If_statement","Common_Lisp","Erlang_(programming_language)","Sweden","Ericsson","T-Mobile","Nortel","Facebook","Électricité_de_France","Scheme_(programming_language)","Lisp_(programming_language)","Apple_Macintosh","Software_simulation","Telescope","OCaml","Software_driver","Robot","Embedded_software","Haskell_(programming_language)","Scala_(programming_language)","F_Sharp_(programming_language)","Lisp_(programming_language)","Standard_ML","Clojure","Comparison_of_programming_paradigms","Eager_evaluation","List_of_functional_programming_topics","Nested_function","Opal_(programming_language)","Cambridge_University_Press","Mark_Jason_Dominus","Morgan_Kaufmann","Prentice_Hall","Prentice_Hall","Macmillan_Technical_Publishing","Addison-Wesley_Longman_Limited"]}